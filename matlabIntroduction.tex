% !TeX encoding = UTF-8
% !TeX program = pdfLaTeX
% !TeX root = matlab-exercises-emaip.tex
% !TeX spellcheck = en_GB
\section{Matlab introduction}
\todo[inline]{Add Matlab introduction exercises}
\todo[inline]{Add exercises about systems of linear equations}


\subsection{If statements}

\todo[inline]{Use this as inspiration for introducing if statements \url{https://www.learnbyexample.org/python-if-else-elif-statement/}¨}

\todo[inline]{Experiment with decision tables for specifying branching behaviour \url{https://www.hillelwayne.com/decision-tables/}}



\subsection{Formatting variables with sprintf}

To show a numeric value in a string in a specific way can be 
done with the function \verb!sprintf!.
The command takes one or more input arguments.
The first argument is a format specifier and the rest
of the arguments are the values that will be inserted 
into the string.
Eg. to display the value of $\pi$ with 5 decimals
along with a descriptive text, the following code 
can be used:
\begin{lstlisting}
>> sprintf("The value of pi is: %.5f", pi)
ans = "The value of pi is: 3.14159"
\end{lstlisting}
It is also possible to insert multiple variables
of different types into the string, this is demonstrated 
here.
\begin{lstlisting}
>> sprintf("My name is %s. I was born in %d.", "Henrik", 1983)
ans = "My name is Henrik. I was born in 1983."
\end{lstlisting}
To display the formatted string in the console
instead of returning it, the function
\verb!fprintf! can be used.
\begin{lstlisting}
>> fprintf("Pi is %.2f\n", pi)
Pi is 3.14
\end{lstlisting}
Read more about the format specifiers in the documentation
\begin{lstlisting}
>> help sprintf
\end{lstlisting}




\begin{ex}
Create a function for entering phasors into matlab.
The function signature should be:
\begin{lstlisting}
function res = phasor(magnitude, direction)
\end{lstlisting}
where \verb!magnitude! is the amplitude of the 
phasor to generate and \verb!direction! is the phase offset
in degrees.
Use the following examples to test the function:
\begin{lstlisting}
>> phasor(2, 45)
ans = 1.4142 + 1.4142i
>> phasor(3, 90)
ans = 0.0000 + 3.0000i
>> phasor(1, 135)
ans = -0.7071 + 0.7071i
\end{lstlisting}
\begin{hint}
A phasor is defined as 
\begin{align*}
\textrm{magnitude} \cdot e^{i \cdot \textrm{direction}}
\end{align*}
where the direction is specified in radians
\end{hint}
\begin{sol}
A solution is:
\begin{lstlisting}
function res = phasor(magnitude, direction)

res = magnitude * exp(1i*direction*pi / 180);

end\end{lstlisting}
\end{sol}
\begin{solutionfile}{phasor_test.m}
function tests = phasor_test
    tests = functiontests(localfunctions);
end


%% Format phasor for human reading
function test01(testCase)
    actual_value = phasor(2, 45);
    expected_value = 2*sin(pi / 4) + 2*cos(pi/4)*1i;
    testCase.verifyEqual(actual_value, expected_value,...
        'RelTol', 0.000001);
end
\end{solutionfile}
\begin{solutionfile}{phasor.m}
function res = phasor(magnitude, direction)

res = magnitude * exp(1i*direction*pi / 180);

end
\end{solutionfile}
\end{ex}


\begin{ex}
Create a function that displays the magnitude and 
phase offset (in degrees) of a phasor.
Both magnitude and phase offset should be shown with six 
decimal values.
The function signature should be:
\begin{lstlisting}
function res = show_phasor(value)
\end{lstlisting}
Use the following examples to test the function:
\begin{lstlisting}
>> show_phasor(1+i)
ans = "1.414214 < 45.000000"
>> show_phasor(2-3*i)
ans = "3.605551 < -56.309932"
\end{lstlisting}
\begin{hint}
The functions \verb!abs! and \verb!angle! will be helpful together with the \verb!sprintf! function.
\end{hint}
\begin{sol}
A solution is:
\begin{lstlisting}
function res = show_phasor(value)

magnitude = abs(value);
phase_offset = angle(value) * 180 / pi;
res = sprintf("%.6f < %.6f", magnitude, phase_offset);

end
\end{lstlisting}
\end{sol}
\begin{solutionfile}{show_phasor.m}
function res = show_phasor(value)

magnitude = abs(value);
phase_offset = angle(value) * 180 / pi;
res = sprintf("%.6f < %.6f", magnitude, phase_offset);

end
\end{solutionfile}
\begin{solutionfile}{show_phasor_test.m}
function tests = show_phasor_test
    tests = functiontests(localfunctions);
end


%% Format phasor for human reading
function test01(testCase)
    actual_value = show_phasor(2);
    expected_value = "2.000000 < 0.000000";
    testCase.verifyEqual(actual_value, expected_value);
end

function test02(testCase)
    actual_value = show_phasor(2 + 2*1i);
    expected_value = "2.828427 < 45.000000";
    testCase.verifyEqual(actual_value, expected_value);
end
\end{solutionfile}
\end{ex}


\subsection{For loops}

Consider the task of adding all integers from 1 to 9
and storing the result in the variable \verb!val!;  
this can be achieved with the following code 
\begin{lstlisting}
val = 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9
\end{lstlisting}
This is straightforward to write, but does not scale
as well as possible.
Adding all integers from 1 to 100 with a similar method
is still possible although impractical.
The task of adding all integers from 1 to 1000000 
is impractical, so lets look at better ways of doing such 
calculations.

The first step to make the code easier to write, does the
direct opposite thing; it makes the code much longer, but it 
also gives it a more repeating structure, which soon will be 
exploited 
\begin{lstlisting}
val = 0;
val = val + 1;
val = val + 2;
val = val + 3;
val = val + 4;
val = val + 5;
val = val + 6;
val = val + 7;
val = val + 8;
val = val + 9;
val
\end{lstlisting}
It still bothers me that the line where \verb!val! is updated
changes from line to line.
To avoid this a helper variable $k$ is introduced.
Before each update of \verb!val! the value of $k$ is 
increased by one and then the update rule can be used.
\begin{lstlisting}
val = 0;
k = 1;
val = val + k;
k = 2;
val = val + k;
k = 3;
val = val + k;
k = 4;
val = val + k;
k = 5;
val = val + k;
k = 6;
val = val + k;
k = 7;
val = val + k;
k = 8;
val = val + k;
k = 9;
val = val + k;
val
\end{lstlisting}
To tell matlab to repeat the update rule \verb!val = val + k! for
all values of $k$ from 1 to 9, the following code can be used:
\begin{lstlisting}
val = 0;
for k = 1:9
    val = val + k;
end
val
\end{lstlisting}
Compared with the first approach of manually typing
all the integers in the range 1 to 9, it takes a bit more space, 
but the code has become much easier to adapt to other problems.


\begin{ex}\label{exSumIntegersUp100}%
Determine the value of 
\begin{align*}
\sum_{k = 1}^{100} k = 1 + 2 + 3 + \ldots + 98 + 99 + 100
\end{align*}
In other words calculate the sum of all integers from 1 to 100.
\begin{hint}
A for loop will be a good structure to use.
The answer is 5050.
\end{hint}
\begin{sol}
A solution is:
\begin{lstlisting}
val = 0;
for k = 1:100
    val = val + k;
end
val
\end{lstlisting}
\end{sol}
\end{ex}

\begin{ex}
Determine the value of 
\begin{align*}
\sum_{k = 1}^{100} \sin(k) = \sin(1) + \sin(2) + \ldots + \sin(99) + \sin(100)
\end{align*}
\begin{hint}
A for loop will be a good structure to use.
The answer is -0.1272.
\end{hint}
\begin{sol}
A solution is:
\begin{lstlisting}
val = 0;
for k = 1:100
    val = val + sin(k);
end
val
\end{lstlisting}
\end{sol}
\end{ex}


\begin{ex}
Test the following expression by selecting a positive integer $n$
and evaluate both sides of the expression using the selected value.
\begin{align*}
\sum_{i = 1}^n i = \frac{n \cdot (n + 1)}{2}
\end{align*}
Repeat this with three different value of $n$.
\begin{hint}
Look at the code from exercise \ref{exSumIntegersUp100}.
It can be adapted to evaluate the left hand side of the expression.
\end{hint}
\begin{sol}
A solution is:
\begin{lstlisting}
n = 234;
val_left = 0;
for k = 1:n
    val_left = val_left + k;
end
val_left
val_right = n * (n + 1) / 2
\end{lstlisting}
\end{sol}
\end{ex}


\begin{ex}
Test the following expression by selecting a positive value $a$
which is not one and an integer $n$
and evaluate both sides of the expression using the selected value.
\begin{align*}
\sum_{i = 0}^n a^i = \frac{1 - a^{n + 1}}{1 - a}
\end{align*}
Repeat this with three different value of $n$.
\begin{hint}
Look at the code from exercise \ref{exSumIntegersUp100}.
It can be adapted to evaluate the left hand side of the expression.
\end{hint}
\begin{sol}
A solution is:
\begin{lstlisting}
a = 1.2;
n = 43;
val_left = 0;
for k = 0:n
    val_left = val_left + a^k;
end
val_left
val_right = (1 - a^(n + 1)) / (1 - a)
\end{lstlisting}
\end{sol}
\end{ex}


\subsection{While loops}

\todo[inline]{Write about code indentation \url{https://dev.to/sanjaysinghrajpoot/why-indentation-is-more-important-than-coding-4fn1}}

\subsection{Plot of secant lines}

\begin{ex}
Draw multiple secant lines on the same figure.
The distance between the points that define the secant line
should be reduced before plotting the next secant line.
Use the following distances between the $x$ values:
$h \in {0.2, 0.1, 0.05, 0.02, 0.01}$.
Please use the template below
\begin{lstlisting}
% Create x values
x = linspace(-3, 6, 100);

% Create a function handle for the function to plot.
fh = @(x) 2*x.^2 - x + 1;

% Find the two end points of the secant to plot.
h = 2;
x0 = 0.2;
x1 = x0 + h;
y0 = fh(x0);
y1 = fh(x1);

% Open a figure and plot the x and y values.
figure(2);
hold off;
% Plot the function
plot(x, fh(x));
hold on;
plot([x0, x1], [y0, y1], 'o-');
\end{lstlisting}
\begin{hint}
\end{hint}
\begin{sol}
A solution is:
\begin{lstlisting}
\end{lstlisting}
\end{sol}
\end{ex}

%
%%% Indskrive vektorer og matricer
%A = [1, 2, 3; 2, 3, 1; 1, 1, 1]
%B = [1, 1, 1; 1, 2, 4; 7, 6, 5]
%C = [1; 2; 3]
%
%
%%% Addition
%disp('addition');
%A + A
%A + B
%B + A
%B + B
%
%
%%% Multiplikation
%disp('multiplikation');
%A * A
%A * B
%B * A
%B * B
%
%
%%% 
%% Transponering
%A
%transpose(A)
%A'
%
%
%%% Opgave
%% Find nogle opgaver med matricer og vektorer.
%% Tjek jeres resultater ved at få Matlab til at udføre de samme beregninger
%% som I har gjort i hånden.
%
%
%
%%%
%% Løsning af lineære ligningssystemer
%
%% Givet ligningerne
%% 2*x1 + 5*x2 = 2 og -4*x1+3*x2 = -30.
%% Kan koefficient matricen A og værdi vektoren b opskrives.
%A = [2, 5; -4, 3];
%b = [2; -30];
%
%% Ud fra værdi vektoren og koefficient matricen, kan 
%% løsningen til ligningssystemet bestemmes på følgende 
%% tre forskellige måder.
%A \ b
%inv(A) * b
%linsolve(A, b)
%
%
%%%
%% Opgave
%% Plot ligningerne x + 2y = 3 og 2x - y = 2 i det samme 
%% koordinatsystem.
%% Opskriv ligningsystemet på matrix form og løs det via 
%% linsolve eller lign.
%% Plot løsningen sammen med de to ligninger.
%% Tjek i hånden at det fremkomne resultat løser de oprindelige 
%% ligninger.
%% teknik.
%
%
%
%
%%%
%% Opgave
%% Der er en fejl i den gauss elimination der fremgår herunder.
%% Benyt funktionen rref (reduced row echelon form), til at 
%% finde fejlen, ved at anvende rref på de forskellige delresultater.
%[1, 2, 3, 1; 3, 2, 1, 1; 1, 1, 2, 1]
%[1, 2, 3, 1; 0, -4, -8, -2; 0, -1, -1, 0]
%[1, 2, 3, 1; 0, 1, -2, 0.5; 0, -2, -1, 0]
%[1, 2, 3, 1; 0, 1, -2, 0.5; 0, 0, -5, 1]

%
%\subsection{Compare derivatives}
%
%\begin{ex}
%\begin{lstlisting}
%%% Sammenlign funktion og dens afledte
%x = linspace(-0.5, 6.2, 100);
%fh = @(x) sin(x);
%fh_prime = @(x) cos(x);
%
%figure(3);
%hold off;
%plot(x, fh(x));
%hold on;
%plot(x, fh_prime(x), 'r');
%legend("f(x)", "f'(x)")
%title("Symbolsk afledte")
%
%
%%% Numerisk estimering af afledte
%% Definer x vaerdier funktionen skal plottes for
%x = linspace(-0.5, 6.2, 100);
%dx = 0.001;
%xprime = x + dx;
%
%% Beregn y vaerdier som skal plottes
%fh = @(x) sin(x);
%y = fh(x);
%yprime = sin(xprime);
%dy = yprime - y;
%derivative = dy / dx;
%
%% Aabn en figur og plot x og y vaerdierne.
%figure(2);
%plot(x, fh(x));
%% Hold fast i det der allerede er plottet.
%hold on;
%plot(x, derivative);
%hold off;
%legend("f(x)", "f'(x)")
%title("Numerisk afledte")
%
%
%
%%% Opgave
%% Sammenlign den analytisk afledte af funktionen 
%% f(x) = (3*x^2+sin(4*x))^2
%% med den numerisk afledte.
%% Benyt gerne koden herover.
%
%
%
%%% Numerisk beregning af graense vaerdier (1.1, 1.01, 1.001, 1.0001, 1.00001, ...)
%
%% Soerg for at matlab skriver komma tal med mange decimaler
%% efter kommaet.
%format long;
%
%% Definer funktionen der skal undersoeges, og hvilken vaerdi x
%% skal gaa mod i graensen.
%fh = @(x) (x.^2 - 1) ./ (x - 1);
%xval = 1;
%
%% Lav en liste med en raekke vaerdier, der gradvist kommer naermere
%% graensevaerdien.
%xvals = xval + 10.^(-linspace(1, 10, 10));
%approx_limits = fh(xvals);
%figure(3);
%plot(xvals, approx_limits, 'o:');
%
%% Skift tilbage til normal visning af kommatal.
%format short;
%
%\end{lstlisting}
%\begin{hint}
%\end{hint}
%\begin{sol}
%A solution is:
%\begin{lstlisting}
%\end{lstlisting}
%\end{sol}
%\end{ex}



\subsection{Find minima}

%%% Finde minima af en funktion
%% Lav en function handle til den funktion der skal plottes.
%% Det gør det lettere at tilpasse koden senere.
%% Notationen med x.^2, handler om at funktionen skal virke på
%% vektorer.
%fh = @(x) 2*x.^2 - x + 1;
%initial_guess = 1;
%x_min = fminsearch(fh, initial_guess);
%
%% Definer x værdier funktionen skal plottes for
%x = linspace(-1, 2, 100);
%
%% Åbn en figur og plot x og y værdierne.
%figure(1);
%hold off;
%plot(x, fh(x));
%hold on;
%plot(x_min, fh(x_min), 'o');
%
%
%%%
%% Opgave
%% Bestem minima af funktionen f(x) = x + 2/x.
%% Se udelukkende på positive værdier af x.
%% Plot funktionen og indsæt et passende startgæt i 
%% kaldet til fminsearch.
%
%
%
%
%%%
%% Opgave
%% Bestem minima af funktionen f(x) = x^2 + 1 / x.
%
%
%
%
%
%
%%% Finde maksimum af en funktion

\begin{lstlisting}
% Make a function handle to the function that is to be
% plotted. This makes it easier to adapt the code later.
% The notation \verb!x.^2!, is to ensure that the function
% also works on vectors.
fh = @(x) -2*x.^2 - 3*x + 1;

% Locate the maximum value of the function (notice the
% minus in the function handle). 
% Use an initial guess of x = 1.
x_min = fminsearch(@(x) -fh(x), 1);

x = linspace(-1, 2, 100);

% Open a figure and plot associated x and y values.
figure(1);
hold off;
plot(x, fh(x));
hold on;
% Indicate the location of the maxima.
plot(x_min, fh(x_min), 'o');
\end{lstlisting}


%
%
%
%%%
%% Opgave
%% Find et lokalt maksimum af funktionen 
%% f(x) = cos(3 - x) * exp(-x^2)
%
%
%%%
%% Opgave
%% Find det globale maksimum af funktionen 
%% f(x) = cos(3 - x) * exp(-x^2)
%



\subsection{Plotting inverse functions}

\begin{ex}
Plot the function $f(x) = \sin(x)$ on the interval $x \in [-\pi/2, \pi/2]$
and determine whether the function has an inverse.
The template below might be helpful.
\begin{lstlisting}
% Plot of functions and their inverse
x = linspace(0, 3, 100);
y = sqrt(x);
figure(1);
hold off;
plot(x, y);
hold on; 
plot(y, x);
plot(x, x, 'k:');
legend('f(x)', 'inverse function');
\end{lstlisting}
\begin{hint}
If a function has an inverse, it should be one-to-one (en-en-tydig).
\end{hint}
\begin{sol}
A solution is:
\begin{lstlisting}
x = linspace(0, 3, 100);
y = sin(x);
figure(1);
hold off;
plot(x, y);
hold on; 
plot(y, x);
plot(x, x, 'k:');
legend('f(x)', 'inverse function');
\end{lstlisting}
\end{sol}
\end{ex}



\begin{ex}
Plot the function $f(x) = \cos(x)$ on the interval $x \in [-pi/2, pi/2]$
and determine whether the function has an inverse.
\begin{lstlisting}
\end{lstlisting}
\begin{hint}
If a function has an inverse, it should be one-to-one (en-en-tydig).
\end{hint}
\begin{sol}
A solution is:
\begin{lstlisting}
\end{lstlisting}
\end{sol}
\end{ex}




\begin{ex}\label{exfzero}%
Solve the equation $0 = 4 + x - x^2$ using the \verb!fzero! function.
How many solutions would you expect to find? How many solutions do 
you actually find?
The template below might be useful:
\begin{lstlisting}
fh = @(x) 0.2 + sin(x);
x = linspace(0, 6, 100);
y = fh(x);
figure(2);
hold off;
plot(x, y); 
guess = 2;
root = fzero(fh, guess)
hold on
plot(root, 0, 'o');
\end{lstlisting}
\begin{hint}
\end{hint}
\begin{sol}
A solution is:
\begin{lstlisting}
\end{lstlisting}
\end{sol}
\end{ex}

\begin{ex}
This exercise is a continuation from \ref{exfzero}.
Get details from \verb!fzero! about how the solution was found.
Look at the documentation to see how.
\begin{hint}
\begin{lstlisting}
help fzero
\end{lstlisting}
\end{hint}
\begin{sol}
A solution is:
\begin{lstlisting}
options = optimset('Display','iter');
fh = @(x) 0.2 + sin(x);
guess = 2;
[x, fval] = fminsearch(fh, guess, options)
\end{lstlisting}
\end{sol}
\end{ex}


\section{Code structure and code indentation}

\todo[inline]{Skriv om god kodestil. Dvs indrykning af koden. Gode variabel navne.}

\todo[inline]{Skriv om explanatory variable and function names \url{https://blog.thepete.net/blog/2021/06/24/explaining-variable/}}
 